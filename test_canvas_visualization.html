<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas可视化测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        canvas {
            border: 1px solid #ccc;
            background: #fafafa;
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Canvas可视化测试</h1>
        <div class="controls">
            <button onclick="loadVisualizationData()">加载可视化数据</button>
            <button onclick="resetCamera()">重置视角</button>
            <button onclick="toggleGrid()">切换网格</button>
        </div>
        <canvas id="canvas" width="800" height="600"></canvas>
        <div class="info">
            <h3>测试说明：</h3>
            <ul>
                <li>蓝色矩形：房间</li>
                <li>棕色线条：物理通道</li>
                <li>红色虚线：房间之间的连接</li>
                <li>点击"加载可视化数据"按钮来测试API</li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let showGrid = true;
        let visualizationData = null;

        async function loadVisualizationData() {
            try {
                const formData = new FormData();
                formData.append('filename', 'chapel_of_the_storm_dragon.json');
                
                const response = await fetch('http://localhost:5001/api/visualize-data-by-filename', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                if (data.success) {
                    visualizationData = data.visualization_data;
                    console.log('加载的数据:', visualizationData);
                    render();
                } else {
                    alert('加载失败: ' + data.error);
                }
            } catch (error) {
                alert('请求失败: ' + error.message);
            }
        }

        function render() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 应用变换
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);
            
            // 渲染网格
            if (showGrid) {
                renderGrid();
            }
            
            // 渲染通道
            if (visualizationData) {
                renderCorridors();
                renderRooms();
            }
            
            ctx.restore();
        }

        function renderGrid() {
            const gridSize = 50;
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 1 / zoom;
            ctx.globalAlpha = 0.3;
            
            const startX = Math.floor(-offsetX / zoom / gridSize) * gridSize;
            const startY = Math.floor(-offsetY / zoom / gridSize) * gridSize;
            const endX = startX + canvas.width / zoom + gridSize;
            const endY = startY + canvas.height / zoom + gridSize;
            
            for (let x = startX; x <= endX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }
            
            for (let y = startY; y <= endY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
        }

        function renderCorridors() {
            for (const corridor of visualizationData.corridors) {
                // 根据通道类型设置不同的样式
                if (corridor.connection_type === 'room_to_room') {
                    // 房间之间的连接线
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 4 / zoom;
                    ctx.setLineDash([5, 5]);
                } else {
                    // 物理通道
                    ctx.strokeStyle = '#8b4513';
                    ctx.lineWidth = (corridor.width || 6) / zoom;
                    ctx.setLineDash([]);
                }
                
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // 绘制通道线条
                ctx.beginPath();
                ctx.moveTo(corridor.start.x, corridor.start.y);
                ctx.lineTo(corridor.end.x, corridor.end.y);
                ctx.stroke();
                
                // 绘制通道端点
                ctx.fillStyle = ctx.strokeStyle;
                ctx.beginPath();
                ctx.arc(corridor.start.x, corridor.start.y, 3 / zoom, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(corridor.end.x, corridor.end.y, 3 / zoom, 0, 2 * Math.PI);
                ctx.fill();
                
                // 重置线条样式
                ctx.setLineDash([]);
            }
        }

        function renderRooms() {
            const roomColors = {
                room: '#3498db',
                chamber: '#e74c3c',
                boss: '#f39c12',
                treasure: '#f1c40f'
            };
            
            for (const room of visualizationData.rooms) {
                // 绘制房间
                ctx.fillStyle = roomColors[room.type] || '#3498db';
                ctx.fillRect(room.x, room.y, room.width, room.height);
                
                // 绘制边框
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2 / zoom;
                ctx.strokeRect(room.x, room.y, room.width, room.height);
                
                // 绘制标签
                ctx.fillStyle = '#ffffff';
                ctx.font = `${12 / zoom}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    room.type,
                    room.x + room.width / 2,
                    room.y + room.height / 2
                );
            }
        }

        function resetCamera() {
            zoom = 1;
            offsetX = 0;
            offsetY = 0;
            render();
        }

        function toggleGrid() {
            showGrid = !showGrid;
            render();
        }

        // 鼠标事件处理
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                offsetX += deltaX;
                offsetY += deltaY;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(3, zoom * delta));
            render();
        });

        // 初始渲染
        render();
    </script>
</body>
</html> 